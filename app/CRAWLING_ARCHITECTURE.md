# 크롤링 코드 아키텍처 설계 분석

## 현재 상황

현재 프로젝트에서는 FastAPI 백엔드에서 두 가지 주요 기능을 담당하고 있습니다:
1. AI 챗봇 기능 (OpenAI API를 사용한 대화 처리)
2. 공공데이터 API 호출 및 데이터 처리

리팩토링 과정에서 공공데이터 API 호출 관련 코드는 Java Spring Boot 백엔드로 이전하기로 결정되었습니다. 그러나 웹 크롤링과 관련된 코드 (`crawl_kead.py`, `upload_to_mongo.py`, `embedding.py`, `mongodb.py`)는 현재 FastAPI 백엔드 내에 남아있습니다.

## 아키텍처 설계 선택지

크롤링 관련 코드 배치에 대해 다음 두 가지 선택지가 있습니다:

### 1. FastAPI 백엔드 내에 크롤링 코드 유지 (현재 방식)

#### 장점:
- 단일 코드베이스로 관리가 편리함
- Python 기반 크롤링 라이브러리(BeautifulSoup, requests 등)를 활용하기 용이함
- OpenAI 임베딩 생성 코드와 함께 위치하여 통합 관리 용이

#### 단점:
- 챗봇 기능과 크롤링 기능이 혼재되어 코드베이스 복잡성 증가
- 챗봇 백엔드 서버에 크롤링 작업의 부하가 추가됨
- 독립적인 스케일링이 어려움 (챗봇 트래픽이 많을 때 크롤링 작업이 영향을 받을 수 있음)
- 서로 다른 기능 간 의존성으로 인한 유지보수 어려움

### 2. 별도 Python 백엔드로 크롤링 코드 분리

#### 장점:
- 관심사 분리(Separation of Concerns)에 따른 명확한 아키텍처
- 각 서비스의 독립적 스케일링 가능
- 서비스별 배포 및 업데이트를 독립적으로 진행 가능
- 챗봇 백엔드의 복잡성 감소 및 집중화
- 크롤링 작업을 백그라운드/스케줄 작업으로 더 쉽게 구성 가능

#### 단점:
- 추가 서비스 관리에 따른 운영 부담
- 서비스 간 데이터 동기화 메커니즘 필요
- 인프라 복잡성 증가

### 3. Java Spring Boot 백엔드에 크롤링 코드 통합

#### 장점:
- 공공데이터 API와 관련 데이터를 단일 서버에서 관리
- MongoDB 등 데이터 저장소를 공유하여 일관된 데이터 접근 가능

#### 단점:
- Python 기반 크롤링 코드를 Java로 재작성해야 함 (비용 증가)
- 웹 크롤링 작업은 Python 라이브러리가 더 풍부하고 편리함

## 권장 아키텍처

현재 프로젝트의 목표와 요구사항을 고려할 때, **별도의 Python 데이터 수집 마이크로서비스**로 분리하는 것이 가장 적합할 것으로 보입니다.

### 권장 아키텍처 구조

```
[사용자] <--> [React 프론트엔드] <--> [FastAPI 챗봇 백엔드] <--> [OpenAI API]
                       ^
                       |
                       v
[Python 크롤링 마이크로서비스] <--> [MongoDB] <--> [Java Spring Boot 백엔드] <--> [공공데이터 API들]
```

### 구현 계획

1. 기존 크롤링 스크립트(`crawl_kead.py`, `upload_to_mongo.py`)를 별도 파이썬 프로젝트로 이전
2. 주기적 실행을 위한 스케줄러 추가 (예: Celery, APScheduler)
3. MongoDB 접근을 위한 별도 유틸리티 모듈 구현
4. 크롤링 상태 모니터링 및 로깅 추가
5. Java Spring Boot 백엔드와 데이터 동기화 메커니즘 구현
   (MongoDB를 공유 데이터 저장소로 활용)

## 전환 단계

1. 현재 코드를 별도 Python 프로젝트로 이전
2. 크롤링 서비스를 독립적으로 실행하는 인프라 구성
3. 공유 MongoDB 인스턴스 구성
4. (선택적) 크롤링 결과 알림 API 추가
5. 크롤링 로직 테스트 및 안정화

## 결론

크롤링 코드는 챗봇 기능과 관심사가 다르므로 별도의 마이크로서비스로 분리하는 것이 장기적으로 더 유연하고 확장 가능한 아키텍처를 제공할 것입니다. 단, 개발 자원과 일정이 제한적인 경우 임시적으로 FastAPI 내에 유지하되 별도 디렉토리로 명확히 분리하여 관리하는 것도 고려할 수 있습니다. 